From 4ea348820e5bc288d5bcd65f5d95af9a1d33f7bf Mon Sep 17 00:00:00 2001
From: Zhang Ying-22455 <ying.zhang22455@nxp.com>
Date: Thu, 17 Jan 2019 13:05:56 +0800
Subject: [PATCH 3/7] i2c: imx: add slave interface for char driver

Signed-off-by: Zhang Ying-22455 <ying.zhang22455@nxp.com>
---
 drivers/i2c/busses/i2c-imx.c |   78 +++++++++++++++++++++++++++++------------
 include/linux/i2c.h          |    7 ++++
 2 files changed, 62 insertions(+), 23 deletions(-)

diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index fa63636..d85bd2f 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -644,10 +644,20 @@ static void i2c_imx_slave_init(struct imx_i2c_struct *i2c_imx)
 	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
 }
 
+void i2c_imx_send_data(struct i2c_client *slave)
+{
+	/* wake up wait queue */
+	wake_up(&slave->tx_queue);
+	slave->valid = 0;
+}
+
 static void i2c_imx_slave_process_irq(struct imx_i2c_struct *i2c_imx)
 {
 	unsigned int status, ctl;
 	u8 data;
+	struct i2c_client *slave;
+
+	slave = i2c_imx->slave;
 
 	status = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);
 	ctl = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
@@ -655,40 +665,55 @@ static void i2c_imx_slave_process_irq(struct imx_i2c_struct *i2c_imx)
 	if (status & I2SR_IAAS) { /* interrupt slave mode */
 		if (status & I2SR_SRW) {
 			/* master wants to read from us */
-			i2c_slave_event(i2c_imx->slave,
-					I2C_SLAVE_READ_REQUESTED, &data);
+
+			/* slave transimt */
 			ctl |= I2CR_MTX;
 			imx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);
-			/*send data */
-			imx_i2c_write_reg(data, i2c_imx, IMX_I2C_I2DR);
+
+			slave->idx = 0;
+			slave->is_master_read = true;
+			slave->valid = 1;
+			/* wait until data is ready */
+			wait_event_timeout(slave->tx_queue,
+					   slave->valid == 0,
+					   IMX_I2C_STATE_DELAY);
+			if (slave->valid != 0) {
+				dev_dbg(&i2c_imx->adapter.dev, "<%s> Timeout\n", __func__);
+			} else {
+				data = slave->tx_buf[0];
+				slave->idx = 1;
+				/*send data */
+				imx_i2c_write_reg(data, i2c_imx, IMX_I2C_I2DR);
+			}
 		} else {
 			/* master wants to write to us */
 			dev_dbg(&i2c_imx->adapter.dev, "write requested");
-			i2c_slave_event(i2c_imx->slave,
-					I2C_SLAVE_WRITE_REQUESTED, &data);
-
-			/*slave receive */
+			slave->is_master_read = false;
+			slave->idx = 0;
+			
+			/* slave receive */
 			ctl &= ~I2CR_MTX;
 			imx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);
-
+#if 0
+			/* wake up wait queue */
+			wake_up(&slave->wait_queue);
+#endif
 			/*dummy read */
 			data = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
 		}
 	} else {
 		if (ctl & I2CR_MTX) { /* transmit mode */
 			if (!(status & I2SR_RXAK)) {	/* received ACK */
-				i2c_slave_event(i2c_imx->slave,
-						I2C_SLAVE_READ_PROCESSED,
-						&data);
 				ctl |= I2CR_MTX;
 				imx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);
-				/*send data */
-				imx_i2c_write_reg(data, i2c_imx, IMX_I2C_I2DR);
+				if(slave->idx < slave->len) {
+					data = slave->tx_buf[slave->idx++];
+					/* send data */
+					imx_i2c_write_reg(data, i2c_imx, IMX_I2C_I2DR);
+				} else {
+				}
 			} else {
 				/* received NAK */
-				i2c_slave_event(i2c_imx->slave,
-						I2C_SLAVE_STOP,
-						&data);
 				ctl &= ~I2CR_MTX;
 				imx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);
 
@@ -703,15 +728,13 @@ static void i2c_imx_slave_process_irq(struct imx_i2c_struct *i2c_imx)
 				data = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
 				dev_dbg(&i2c_imx->adapter.dev,
 					"received 0x%x", data);
-				i2c_slave_event(i2c_imx->slave,
-						I2C_SLAVE_WRITE_RECEIVED,
-						&data);
+				slave->rx_buf[slave->idx++] = data;
 			} else { /* STOP signal is detected*/
 				dev_dbg(&i2c_imx->adapter.dev,
 					"STOP signal detected");
-				i2c_slave_event(i2c_imx->slave,
-						I2C_SLAVE_STOP,
-						&data);
+				if (slave->is_master_read == false)
+					slave->valid = 1;
+				slave->len = slave->idx;
 			}
 		}
 	}
@@ -801,6 +824,9 @@ static int slave_evt_handler(struct imx_i2c_struct *i2c_imx,
 			     enum imx_i2c_events event)
 {
 	u8 reg, data;
+	struct i2c_client *slave;
+
+	slave = i2c_imx->slave;
 
 	switch (event) {
 	case EVT_ENTRY:
@@ -825,6 +851,8 @@ static int slave_evt_handler(struct imx_i2c_struct *i2c_imx,
 			data = 0;
 			set_state(i2c_imx,  STATE_IDLE);
 			dev_dbg(&i2c_imx->adapter.dev, "end of package");
+			slave->len = slave->idx;
+			slave->valid = 1;
 			i2c_slave_event(i2c_imx->slave, I2C_SLAVE_STOP, &data);
 		}
 
@@ -1000,6 +1028,10 @@ static int i2c_imx_reg_slave(struct i2c_client *slave)
 
 	i2c_imx->slave = slave;
 
+	init_waitqueue_head(&slave->tx_queue);
+	slave->idx = 0;
+	slave->valid = 0;
+
 	/* Set the Slave address */
 	imx_i2c_write_reg((i2c_imx->slave->addr << 1), i2c_imx, IMX_I2C_IADR);
 	result = i2c_imx_hw_start(i2c_imx);
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 6422eef..cb6bf6a 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -237,6 +237,13 @@ struct i2c_client {
 	struct list_head detected;
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	i2c_slave_cb_t slave_cb;	/* callback for slave mode	*/
+	bool is_master_read;
+	bool valid;
+	char rx_buf[256];
+	char tx_buf[256];
+	int  len;
+	u8   idx;
+	wait_queue_head_t	tx_queue;
 #endif
 };
 #define to_i2c_client(d) container_of(d, struct i2c_client, dev)
-- 
1.7.1

